

密封类，可以理解为枚举，规定了有限个类型，不可以存在其他类型，但枚举每个枚举常量只存在一个示例，
但是密封类的子类可以有多个示例，所以可以将密封类看做是枚举的拓展，基于枚举，高于枚举，青出于蓝而胜于蓝。

密封类和普通类的区别，在于密封类使用了sealed修饰符，虽然密封类也可以有子类，

**********************但是所有子类都必须在与密封类自身相同的文件中声明**********************
还是上栗子：

    sealed class Time {

    }

    data class Time1(val number: Int) : Time() {
    }

    data class Time2(val number: Int, val name: String) : Time() {
    }
注意：扩展密封类子类的类（间接继承者）可以放在任何位置，而无需在同一个文件中。
使用密封类的关键好处在于使用 when
表达式 的时候，如果能够验证语句覆盖了所有情况，就不需要为该语句再添加一个 else子句了。

    fun main(args: Array<String>) {
        println(list(Time1(5)))
        println(list(Time2(8,"hehe")))
    }

 fun list(time:Time) : String = when(time){
       is Time1 -> "${time.number}"
       is Time2 -> time.name
   }```

---------------------
####后记
关于密封类，使用比较灵活，记住所有子类都必须在与密封类自身相同的文件中声明。